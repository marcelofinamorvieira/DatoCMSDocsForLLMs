# Upload Smart Tag Resource

## Overview

Upload Smart Tags are AI-generated tags that DatoCMS automatically creates for your images using machine learning. These tags help categorize and describe your visual content without manual effort, detecting objects, scenes, concepts, and more.

## API Client Section

`client.uploadSmartTags`

## Installation

```bash
npm install @datocms/cma-client
```

## Basic Usage

```typescript
import { buildClient } from '@datocms/cma-client';

const client = buildClient({ apiToken: 'YOUR_API_TOKEN' });

// Get all available smart tags in the project
const smartTags = await client.uploadSmartTags.list();
// Returns: ['person', 'outdoor', 'nature', 'building', 'food', 'animal', 'text', 'product']

// Smart tags are automatically added to image uploads
const upload = await client.uploads.find('upload-id');
console.log(upload.smart_tags); // ['person', 'outdoor', 'smile']
```

## API Reference

### list() - List All Smart Tags

Retrieve all unique smart tags that have been automatically generated across all uploads in your project.

**Signature**: `list(): Promise<string[]>`

**Returns**: Array of smart tag names (strings)

**Example**:
```typescript
// Get all smart tags
const allSmartTags = await client.uploadSmartTags.list();
// Returns array like: ['person', 'outdoor', 'nature', 'building', 'food', 'animal', 'text', 'product']

// Get raw response
const response = await client.uploadSmartTags.rawList();
// response.data contains the array of smart tags
```

## Understanding Smart Tags

### How Smart Tags Work

Smart tags are automatically generated by DatoCMS using AI/ML image recognition when images are uploaded:

```typescript
// Smart tags are automatically added when an image is uploaded
const upload = await client.uploads.create({
  path: '/path/to/image.jpg'
});

// After processing, the upload will have smart_tags
const processedUpload = await client.uploads.find(upload.id);
console.log(processedUpload.smart_tags);
// ['person', 'outdoor', 'nature', 'tree', 'smile']

// Smart tags are read-only and cannot be manually modified
// They are separate from regular tags
```

### Tag Categories

Smart tags typically fall into several categories:

```typescript
// Object Detection - Physical objects in images
const objects = ['person', 'car', 'building', 'animal', 'furniture', 'food'];

// Scene Detection - Environmental context
const scenes = ['outdoor', 'indoor', 'nature', 'urban', 'beach', 'mountain'];

// Concept Detection - Abstract concepts
const concepts = ['business', 'technology', 'happiness', 'celebration', 'education'];

// Action Detection - Activities and actions
const actions = ['running', 'working', 'cooking', 'dancing', 'meeting'];

// Attribute Detection - Visual properties
const attributes = ['colorful', 'vintage', 'modern', 'minimalist', 'crowded'];
```

## Working with Smart Tags

### Finding Images by Smart Tags

Use smart tags to locate specific types of images:

```typescript
async function findImagesBySmartTag(tagName: string) {
  // Search uploads that have the specific smart tag
  const uploads = await client.uploads.list({
    filter: {
      type: 'image',
      smart_tags: { any_in: [tagName] }
    }
  });
  
  return uploads;
}

// Find all images with people
const peopleImages = await findImagesBySmartTag('person');

// Find outdoor scenes
const outdoorImages = await findImagesBySmartTag('outdoor');

// Find images with multiple smart tags
const uploads = await client.uploads.list({
  filter: {
    type: 'image',
    smart_tags: { all_in: ['person', 'outdoor'] } // Must have both tags
  }
});
```

### Smart Tag Based Search

Build a smart tag-based search system:

```typescript
async function searchBySmartTags(tags: string[], options = {}) {
  const operator = options.matchAll ? 'all_in' : 'any_in';
  
  const uploads = await client.uploads.list({
    filter: {
      type: 'image',
      smart_tags: { [operator]: tags }
    },
    order_by: options.orderBy || '_created_at_DESC',
    page: { limit: options.limit || 30 }
  });
  
  // Enhance results with relevance scoring
  const results = uploads.map(upload => {
    const smartTags = upload.smart_tags || [];
    const matchedTags = tags.filter(tag => smartTags.includes(tag));
    const relevanceScore = matchedTags.length / tags.length;
    
    return {
      upload,
      matchedTags,
      relevanceScore,
      additionalTags: smartTags.filter(tag => !tags.includes(tag))
    };
  });
  
  // Sort by relevance if requested
  if (options.sortByRelevance) {
    results.sort((a, b) => b.relevanceScore - a.relevanceScore);
  }
  
  return results;
}

// Usage examples
const peopleImages = await searchBySmartTags(['person'], {
  limit: 50
});

const outdoorScenes = await searchBySmartTags(['outdoor', 'nature'], {
  matchAll: true,
  sortByRelevance: true
});
```

### Creating Tag Summaries

Analyze the smart tags for an upload:

```typescript
async function getUploadTagSummary(uploadId: string) {
  // Get the upload with smart tags
  const upload = await client.uploads.find(uploadId);
  const smartTags = upload.smart_tags || [];
  
  // Group by category (simplified example)
  const summary = {
    objects: [],
    scenes: [],
    concepts: [],
    attributes: [],
    other: []
  };
  
  const objectWords = ['person', 'car', 'animal', 'building', 'object'];
  const sceneWords = ['outdoor', 'indoor', 'nature', 'urban', 'landscape'];
  const conceptWords = ['business', 'technology', 'education', 'lifestyle'];
  const attributeWords = ['color', 'style', 'modern', 'vintage'];
  
  smartTags.forEach(tag => {
    const name = tag.toLowerCase();
    
    if (objectWords.some(word => name.includes(word))) {
      summary.objects.push(tag);
    } else if (sceneWords.some(word => name.includes(word))) {
      summary.scenes.push(tag);
    } else if (conceptWords.some(word => name.includes(word))) {
      summary.concepts.push(tag);
    } else if (attributeWords.some(word => name.includes(word))) {
      summary.attributes.push(tag);
    } else {
      summary.other.push(tag);
    }
  });
  
  return summary;
}
```

### Combining Smart Tags with Manual Tags

Create a comprehensive tagging system:

```typescript
async function enrichUploadTags(uploadId: string) {
  // Get current upload
  const upload = await client.uploads.find(uploadId);
  
  // Convert smart tags to manual tags with prefix
  const smartTagNames = (upload.smart_tags || []).map(st => `ai:${st}`);
  
  // Ensure manual tags exist
  for (const tagName of smartTagNames) {
    try {
      await client.uploadTags.create({ name: tagName });
    } catch (e) {
      // Tag might already exist
    }
  }
  
  // Combine with existing manual tags
  const allTags = [...new Set([...upload.tags, ...smartTagNames])];
  
  // Update upload with combined tags
  await client.uploads.update(uploadId, {
    tags: allTags
  });
  
  return {
    manual: upload.tags,
    smart: smartTagNames,
    total: allTags.length
  };
}
```

## Smart Tag Analytics

### Tag Distribution Analysis

Understand your media library composition:

```typescript
async function analyzeSmartTagDistribution() {
  // Get all smart tags
  const allSmartTags = await client.uploadSmartTags.list();
  
  // Get uploads to analyze smart tag usage
  const uploads = await client.uploads.list({
    filter: { type: 'image' },
    page: { limit: 500 }
  });
  
  const analysis = {
    totalSmartTags: allSmartTags.length,
    totalImages: uploads.length,
    tagDistribution: new Map(),
    commonCombinations: new Map(),
    imagesWithoutSmartTags: 0,
    averageTagsPerImage: 0
  };
  
  let totalTagCount = 0;
  
  // Analyze each upload
  for (const upload of uploads) {
    const smartTags = upload.smart_tags || [];
    
    if (smartTags.length === 0) {
      analysis.imagesWithoutSmartTags++;
    } else {
      totalTagCount += smartTags.length;
      
      // Count individual tags
      smartTags.forEach(tag => {
        const count = analysis.tagDistribution.get(tag) || 0;
        analysis.tagDistribution.set(tag, count + 1);
      });
      
      // Track tag combinations
      if (smartTags.length > 1) {
        const combination = smartTags.sort().join(',');
        const comboCount = analysis.commonCombinations.get(combination) || 0;
        analysis.commonCombinations.set(combination, comboCount + 1);
      }
    }
  }
  
  // Calculate average
  analysis.averageTagsPerImage = uploads.length > 0 
    ? (totalTagCount / uploads.length).toFixed(2) 
    : 0;
  
  // Sort tag distribution
  const sortedTags = Array.from(analysis.tagDistribution.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 20);
  
  analysis.topSmartTags = sortedTags.map(([tag, count]) => ({
    tag,
    count,
    percentage: ((count / uploads.length) * 100).toFixed(2)
  }));
  
  return analysis;
}
```

### Content Gap Analysis

Identify missing content types:

```typescript
async function findContentGaps(desiredTags: string[]) {
  const allSmartTags = await client.uploadSmartTags.list();
  const gaps = [];
  
  // Get uploads with smart tags
  const uploads = await client.uploads.list({
    filter: { 
      type: 'image',
      smart_tags: { exists: true }
    }
  });
  
  // Count occurrences of each tag
  const tagCounts = new Map();
  uploads.forEach(upload => {
    (upload.smart_tags || []).forEach(tag => {
      tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);
    });
  });
  
  for (const tagName of desiredTags) {
    const count = tagCounts.get(tagName) || 0;
    
    gaps.push({
      tag: tagName,
      status: count === 0 ? 'missing' : count < 5 ? 'insufficient' : 'adequate',
      count: count
    });
  }
  
  return gaps;
}

// Check for diverse content
const contentNeeds = [
  'diversity', 'teamwork', 'innovation', 'sustainability',
  'customer', 'product', 'office', 'outdoor'
];

const gaps = await findContentGaps(contentNeeds);
console.log('Content gaps:', gaps.filter(g => g.status !== 'adequate'));
```

### Smart Tag Quality Assessment

Monitor smart tag coverage and quality:

```typescript
async function assessSmartTagQuality() {
  const uploads = await client.uploads.list({
    filter: { type: 'image' },
    page: { limit: 200 }
  });
  
  const assessment = {
    totalImages: uploads.length,
    imagesWithSmartTags: 0,
    imagesWithoutSmartTags: 0,
    tagCounts: {
      none: 0,
      few: 0,      // 1-2 tags
      moderate: 0, // 3-5 tags
      many: 0      // 6+ tags
    },
    potentialIssues: [],
    recommendations: []
  };
  
  for (const upload of uploads) {
    const smartTags = upload.smart_tags || [];
    const tagCount = smartTags.length;
    
    if (tagCount === 0) {
      assessment.imagesWithoutSmartTags++;
      assessment.tagCounts.none++;
      
      // Check if image might need reprocessing
      assessment.potentialIssues.push({
        uploadId: upload.id,
        issue: 'no_smart_tags',
        filename: upload.filename,
        uploadDate: upload.created_at
      });
    } else {
      assessment.imagesWithSmartTags++;
      
      if (tagCount <= 2) {
        assessment.tagCounts.few++;
      } else if (tagCount <= 5) {
        assessment.tagCounts.moderate++;
      } else {
        assessment.tagCounts.many++;
      }
    }
  }
  
  // Generate recommendations
  const noTagPercentage = (assessment.imagesWithoutSmartTags / assessment.totalImages) * 100;
  
  if (noTagPercentage > 20) {
    assessment.recommendations.push({
      type: 'reprocessing',
      message: `${noTagPercentage.toFixed(1)}% of images lack smart tags. Consider reprocessing.`,
      affectedCount: assessment.imagesWithoutSmartTags
    });
  }
  
  return assessment;
}
```

## Advanced Patterns

### Smart Tag Based Collections

Create upload filters based on smart tags:

```typescript
async function createSmartTagCollections() {
  const smartTags = await client.uploadSmartTags.list();
  const collections = [];
  
  // Define collection rules based on smart tags
  const collectionRules = [
    {
      name: 'People & Portraits',
      tags: ['person', 'face', 'portrait'],
      matchAll: false
    },
    {
      name: 'Nature & Landscapes',
      tags: ['nature', 'landscape', 'outdoor', 'mountain', 'water'],
      matchAll: false
    },
    {
      name: 'Products & Objects',
      tags: ['product', 'object'],
      matchAll: false
    },
    {
      name: 'Food & Beverages',
      tags: ['food', 'drink', 'beverage'],
      matchAll: false
    },
    {
      name: 'Architecture',
      tags: ['building', 'architecture', 'indoor'],
      matchAll: false
    },
    {
      name: 'Animals & Wildlife',
      tags: ['animal', 'wildlife', 'pet'],
      matchAll: false
    }
  ];
  
  // Create upload filters for each collection
  for (const rule of collectionRules) {
    // Check if relevant tags exist
    const relevantTags = rule.tags.filter(tag => smartTags.includes(tag));
    
    if (relevantTags.length > 0) {
      try {
        const filter = await client.uploadFilters.create({
          name: `Smart: ${rule.name}`,
          filter: {
            type: { eq: 'image' },
            smart_tags: {
              [rule.matchAll ? 'all_in' : 'any_in']: relevantTags
            }
          },
          shared: true
        });
        
        collections.push({
          name: rule.name,
          filter: filter,
          tags: relevantTags
        });
      } catch (error) {
        console.error(`Failed to create filter for ${rule.name}:`, error);
      }
    }
  }
  
  return collections;
}
```

### Smart Tag Monitoring

Monitor smart tag coverage for recent uploads:

```typescript
async function monitorSmartTagCoverage() {
  const recentUploads = await client.uploads.list({
    filter: {
      type: 'image',
      created_at: { 
        gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString() 
      }
    },
    order_by: '_created_at_DESC',
    page: { limit: 100 }
  });
  
  const monitoring = {
    period: 'last_7_days',
    totalUploads: recentUploads.length,
    withSmartTags: 0,
    withoutSmartTags: 0,
    processingDelay: [],
    tagCoverage: new Map(),
    alerts: []
  };
  
  for (const upload of recentUploads) {
    const smartTags = upload.smart_tags || [];
    
    if (smartTags.length > 0) {
      monitoring.withSmartTags++;
      
      // Track tag coverage
      smartTags.forEach(tag => {
        monitoring.tagCoverage.set(
          tag, 
          (monitoring.tagCoverage.get(tag) || 0) + 1
        );
      });
    } else {
      monitoring.withoutSmartTags++;
      
      // Check if processing might be delayed
      const uploadAge = Date.now() - new Date(upload.created_at).getTime();
      const hoursSinceUpload = uploadAge / (1000 * 60 * 60);
      
      if (hoursSinceUpload > 1) {
        monitoring.processingDelay.push({
          uploadId: upload.id,
          filename: upload.filename,
          hoursSinceUpload: hoursSinceUpload.toFixed(1)
        });
      }
    }
  }
  
  // Generate alerts
  const coverageRate = (monitoring.withSmartTags / monitoring.totalUploads) * 100;
  
  if (coverageRate < 80) {
    monitoring.alerts.push({
      type: 'low_coverage',
      severity: 'warning',
      message: `Only ${coverageRate.toFixed(1)}% of recent uploads have smart tags`
    });
  }
  
  return monitoring;
}
```

### Similarity Detection

Find visually similar images based on shared smart tags:

```typescript
async function findSimilarImages(uploadId: string, threshold = 0.5) {
  // Get source upload
  const sourceUpload = await client.uploads.find(uploadId);
  const sourceTags = new Set(sourceUpload.smart_tags || []);
  
  if (sourceTags.size === 0) {
    return [];
  }
  
  // Get all image uploads
  const uploads = await client.uploads.list({
    filter: { type: 'image' },
    page: { limit: 500 }
  });
  
  const similarities = [];
  
  for (const upload of uploads) {
    if (upload.id === uploadId) continue;
    
    const compareTags = new Set(upload.smart_tags || []);
    
    // Calculate Jaccard similarity
    const intersection = [...sourceTags].filter(x => compareTags.has(x));
    const union = new Set([...sourceTags, ...compareTags]);
    const similarity = intersection.length / union.size;
    
    if (similarity >= threshold) {
      similarities.push({
        upload,
        similarity,
        sharedTags: intersection,
        totalTags: union.size
      });
    }
  }
  
  // Sort by similarity
  return similarities.sort((a, b) => b.similarity - a.similarity);
}
```

## Error Handling

```typescript
import { ApiError } from '@datocms/rest-client-utils';

// Handle missing smart tags
const upload = await client.uploads.find('upload-id');
const smartTags = upload.smart_tags || [];

if (smartTags.length === 0) {
  console.log('No smart tags available for this upload');
  // Smart tags might not be generated yet for new uploads
  // or the upload might not be an image
}

// Smart tags are read-only - cannot be modified
try {
  await client.uploads.update('upload-id', {
    smart_tags: ['custom', 'tags'] // This will not work
  });
} catch (error) {
  console.error('Smart tags cannot be manually modified');
}
```

## Limitations

1. **Read-Only**: Smart tags are automatically generated and cannot be created, updated, or deleted
2. **Image Only**: Smart tags are only generated for image uploads
3. **Processing Time**: New uploads may take time before smart tags appear
4. **Language**: Tag names are typically in English
5. **No Confidence Scores**: The API doesn't provide confidence scores for individual tags
6. **Limited Control**: Cannot force regeneration or customize the AI model
7. **Tag Vocabulary**: Limited to the predefined set of tags the AI can recognize

## Best Practices

1. **Complement with Manual Tags**: Use regular tags to add context that AI might miss
2. **Monitor Coverage**: Regularly check that new uploads are getting smart tags
3. **Search Strategy**: Combine smart tags with other filters for precise results
4. **Processing Time**: Allow time for smart tags to be generated after upload
5. **Fallback Strategy**: Have a plan for uploads without smart tags

## Related Resources

- [Uploads](./upload.md) - Upload images for smart tagging
- [Upload Tags](./upload-tag.md) - Manual tagging system
- [Upload Filters](./upload-filter.md) - Create saved filters using smart tags